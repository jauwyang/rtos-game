const uint32_t BALL_SIZE = 5;
const uint32_t HOLE_SIZE = 5;
const uint32_t DIRECTION_ARROW_SIZE = 7;
const uint32_t ARROW_BITMAP_SIZE_WIDTH = 15;
const uint32_t ARROW_BITMAP_MID = (ARROW_BITMAP_SIZE_WIDTH + 1) / 2;


// MUTEX: ballMutex, arrowBitMapMutex
// PROTECTED DATA: golfBall, arrowBitMap
void createArrowBitMap(void *args) {
	while (1) {
		osMutexAcquire(ballMutex, osWaitForever);
		double ballDirection = convertAngle(golfBall->direction);
		double xPos = golfBall->pos.x;
		double yPos = golfBall->pos.y;
		osMutexRelease(ballMutex);

		// Initialize Empty Binary Bitmap with 1 at center
		uint32_t fullArrow[ARROW_BITMAP_SIZE_WIDTH][ARROW_BITMAP_SIZE_WIDTH] = {0};
		fullArrow[ARROW_BITMAP_MID-1][ARROW_BITMAP_MID-1] = 1;  // make center of bit map (where the ball would be) 1

		// Draw Arrow in the 2D Bitmap starting at center of map
		for (uint32_t i = 1; i < DIRECTION_ARROW_SIZE + 1; i++) {  
			uint32_t x = round(i*cos(ballDirection));
			uint32_t y = round(i*sin(ballDirection));
			fullArrow[x + ARROW_BITMAP_MID - 1][y+ ARROW_BITMAP_MID - 1] = 1;
		}

		// Truncate 2D Arrow Array into array of only the quadrant that has the arrow
		// -> Get end tip of arrow to determine quandrant arrow lies in
		uint32_t xTipOfArrowIndex = round(DIRECTION_ARROW_SIZE*cos(ballDirection)) + ARROW_BITMAP_MID;
		uint32_t yTipOfArrowIndex = round(DIRECTION_ARROW_SIZE*sin(ballDirection)) + ARROW_BITMAP_MID;
		// -> Based on location/quadrant of arrow, store the start and end index of array of the quadrant
		uint32_t startXIndexOfFullArrow = (ARROW_BITMAP_MID - 1 > xTipOfArrowIndex) ? 0 : ARROW_BITMAP_MID - 1;
		uint32_t startYIndexOfFullArrow = (ARROW_BITMAP_MID - 1 > yTipOfArrowIndex) ? 0 : ARROW_BITMAP_MID - 1;
		uint32_t endXIndexOfFullArrow = startXIndexOfFullArrow + ARROW_BITMAP_MID;
		uint32_t endYIndexOfFullArrow = startYIndexOfFullArrow + ARROW_BITMAP_MID;
		// -> Initialize smaller array containing only quadrant 
		uint32_t quadrantArrow[ARROW_BITMAP_MID][ARROW_BITMAP_MID] = {0};
		// -> Initialize index for smaller quadrant array to loop over for bits/image to be copied over (Array has different index than fullArrow array) 
		uint32_t iQuadrantArrowIndex;
		uint32_t jQuadrantArrowIndex;
		// -> Copy bits/image of arrow in fullArrow array into smaller quadrantArrow array
		iQuadrantArrowIndex = 0;
		for (uint32_t iFullArrowIndex = startXIndexOfFullArrow; iFullArrowIndex < endXIndexOfFullArrow; iFullArrowIndex++) {
			jQuadrantArrowIndex = 0;
			for (uint32_t jFullArrowIndex = startYIndexOfFullArrow; jFullArrowIndex < endYIndexOfFullArrow; jFullArrowIndex++) {
				quadrantArrow[iQuadrantArrowIndex][jQuadrantArrowIndex] = fullArrow[iFullArrowIndex][jFullArrowIndex];
				jQuadrantArrowIndex++;
			}
			iQuadrantArrowIndex++;
		}

		// Convert 2D Binary Bitmap (quadrantArrow array) into Hexadecimal bitmap
		// Update arrow bitmap
		//osMutexAcquire(arrowBitMapMutex, osWaitForever);
		for (uint32_t rowOf8Bits = 0; rowOf8Bits < ARROW_BITMAP_MID; rowOf8Bits++) {
			char decimalValueOfRow = convertBinaryArrayToDecimal(quadrantArrow[rowOf8Bits], ARROW_BITMAP_MID);
			arrowBitMap[rowOf8Bits] = decimalValueOfRow;
		}
		//osMutexRelease(arrowBitMapMutex);
		
		drawSpriteAt(xPos, yPos, arrowBitMap, ARROW_BITMAP_MID);

	}
}

